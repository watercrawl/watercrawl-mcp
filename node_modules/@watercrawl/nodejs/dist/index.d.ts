import { BaseAPIClient } from './base.js';
import type { CrawlRequest, CrawlResult, SpiderOptions, PageOptions, PluginOptions, CrawlEvent, SearchRequest, SearchOptions, SearchEvent, SearchResult, SitemapNode } from './types.js';
export * from './types.js';
export declare class WaterCrawlAPIClient extends BaseAPIClient {
    getCrawlRequestsList(page?: number, pageSize?: number): Promise<{
        results: CrawlRequest[];
    }>;
    getCrawlRequest(itemId: string): Promise<CrawlRequest>;
    createCrawlRequest(url: string, spiderOptions?: SpiderOptions, pageOptions?: PageOptions, pluginOptions?: PluginOptions): Promise<CrawlRequest>;
    stopCrawlRequest(itemId: string): Promise<null>;
    downloadCrawlRequest(itemId: string): Promise<CrawlResult[]>;
    monitorCrawlRequest(itemId: string, download?: boolean): AsyncGenerator<CrawlEvent, void, unknown>;
    getCrawlRequestResults(itemId: string): Promise<{
        results: CrawlResult[];
    }>;
    /**
     * Download the content of a crawl result
     * @deprecated This method will be removed in a future version. Please use alternative methods for downloading result data.
     */
    downloadResult(resultObject: CrawlResult): Promise<Record<string, any>>;
    scrapeUrl(url: string, pageOptions?: PageOptions, pluginOptions?: PluginOptions, sync?: boolean, download?: boolean): Promise<Record<string, any> | CrawlRequest>;
    /**
     * Get a crawl request for sitemap operations
     * @param crawlRequest Crawl request object or UUID
     * @returns Promise with the crawl request
     * @throws Error if the sitemap is not available
     */
    private getCrawlRequestForSitemap;
    /**
     * Download the sitemap for a crawl request
     * @param crawlRequest Crawl request object or UUID
     * @returns Promise with the sitemap data
     */
    downloadSitemap(crawlRequest: string | CrawlRequest): Promise<SitemapNode[]>;
    /**
     * Download the sitemap as a graph representation for visualization
     * @param crawlRequest Crawl request object or UUID
     * @returns Promise with the sitemap graph data
     */
    downloadSitemapGraph(crawlRequest: string | CrawlRequest): Promise<any>;
    /**
     * Download the sitemap as a markdown document
     * @param crawlRequest Crawl request object or UUID
     * @returns Promise with the sitemap markdown content
     */
    downloadSitemapMarkdown(crawlRequest: string | CrawlRequest): Promise<string>;
    /**
     * Get a paginated list of search requests
     * @param page Page number (1-indexed, default: 1)
     * @param pageSize Number of items per page (default: 10)
     * @returns Promise with paginated search requests
     */
    getSearchRequestsList(page?: number, pageSize?: number): Promise<{
        results: SearchRequest[];
    }>;
    /**
     * Get details of a specific search request
     * @param itemId UUID of the search request
     * @param download If true, download results; if false, return URLs
     * @returns Promise with search request details
     */
    getSearchRequest(itemId: string, download?: boolean): Promise<SearchRequest>;
    /**
     * Create a new search request
     * @param query Search query string
     * @param searchOptions Search options
     * @param resultLimit Maximum number of results to return
     * @param sync If true, wait for results; if false, return immediately
     * @param download If true, download results; if false, return URLs
     * @returns If sync=true: Complete search results; If sync=false: Search request object
     */
    createSearchRequest(query: string, searchOptions?: SearchOptions, resultLimit?: number, sync?: boolean, download?: boolean): Promise<SearchRequest | SearchResult[]>;
    /**
     * Monitor a search request in real-time
     * @param itemId UUID of the search request to monitor
     * @param download If true, download results; if false, return URLs
     * @returns AsyncGenerator yielding search events
     */
    monitorSearchRequest(itemId: string, download?: boolean): AsyncGenerator<SearchEvent, void, unknown>;
    /**
     * Stop a running search request
     * @param itemId UUID of the search request to stop
     * @returns Promise that resolves when the request is stopped
     */
    stopSearchRequest(itemId: string): Promise<null>;
}
